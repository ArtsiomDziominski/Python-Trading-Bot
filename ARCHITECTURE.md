# Архитектура и принципы работы Trading Bot System

## Что это за проект?

Trading Bot System - это бэкенд-система для создания и управления автоматическими торговыми ботами на криптовалютных биржах Binance и Bybit. Система позволяет пользователям:

- Создавать торговых ботов с различными стратегиями
- Управлять ботами через REST API
- Получать уведомления о событиях через Telegram и Email
- Отслеживать статусы ордеров в реальном времени
- Анализировать статистику торговли

## Общая архитектура

Система построена на микросервисной архитектуре с использованием Docker контейнеров:

```
┌─────────────────────────────────────────────────────────┐
│                    Клиент (Frontend)                     │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
         ┌───────────────────────┐
         │   FastAPI Backend     │
         │   (REST API)           │
         └───────┬───────────────┬─┘
                 │               │
        ┌────────▼────┐  ┌──────▼────────┐
        │ PostgreSQL   │  │    Redis      │
        │  (БД)        │  │  (Очереди)    │
        └──────────────┘  └──────┬────────┘
                                  │
                    ┌─────────────┼─────────────┐
                    │             │             │
         ┌──────────▼──┐  ┌───────▼──────┐  ┌──▼──────────┐
         │ Telegram Bot│  │ Trading Bots  │  │ Email       │
         │ Container   │  │ Containers    │  │ Service     │
         └─────────────┘  └──────────────┘  └─────────────┘
```

## Компоненты системы

### 1. FastAPI Backend (Основной API сервер)

**Что делает:**
- Предоставляет REST API для управления системой
- Обрабатывает запросы от клиентов
- Управляет пользователями, ботами и ордерами
- Координирует работу всех компонентов

**Основные модули:**

#### Аутентификация (`app/api/auth.py`)
- Регистрация новых пользователей
- Вход в систему (JWT токены)
- Получение информации о текущем пользователе

**Как работает:**
1. Пользователь регистрируется с email и паролем
2. Пароль хешируется через bcrypt
3. При входе генерируется JWT токен
4. Токен используется для доступа к защищенным endpoints

#### Управление ботами (`app/api/bots.py`)
- Создание ботов с параметрами стратегии
- Просмотр списка ботов пользователя
- Обновление настроек бота
- Удаление ботов

**Как работает:**
1. Пользователь создает бота через API
2. API ключи биржи шифруются (AES/Fernet)
3. Конфигурация бота сохраняется в БД
4. Бот получает команды через Redis Queue

#### Система ордеров (`app/api/orders.py`)
- Выставление ордеров на биржу
- Просмотр истории ордеров
- Отслеживание статусов

**Как работает:**
1. Пользователь создает ордер через API
2. Система расшифровывает API ключи бота
3. Ордер отправляется на биржу через ccxt
4. Ордер сохраняется в БД
5. Задача мониторинга добавляется в Redis Queue

#### Уведомления (`app/api/notifications.py`)
- Настройка каналов уведомлений (Email, Telegram)
- Выбор типов событий для уведомлений
- Управление настройками

### 2. PostgreSQL (База данных)

**Хранит:**

#### Таблица `users`
- Информация о пользователях
- Email, хешированный пароль
- Статус активности

#### Таблица `bots`
- Конфигурация ботов
- Зашифрованные API ключи бирж
- Статус бота (активен/остановлен)
- Параметры стратегии

#### Таблица `orders`
- История всех ордеров
- Статусы ордеров
- Связь с ботами и биржами

#### Таблица `notification_settings`
- Настройки уведомлений пользователей
- Email адреса
- Telegram chat_id
- Включенные типы событий

### 3. Redis (Очереди и кеш)

**Используется для:**

#### Очередь мониторинга ордеров (`order_monitoring_queue`)
- Задачи на проверку статусов ордеров
- Формат: `{"order_id": 123, "action": "monitor"}`

#### Очередь уведомлений (`notification_queue`)
- Задачи на отправку уведомлений
- Формат: `{"user_id": 1, "event_type": "order_filled", "data": {...}}`

**Как работает:**
1. Backend добавляет задачу в очередь через `LPUSH`
2. Воркеры (Telegram бот, Email сервис) получают задачи через `BRPOP`
3. Задачи обрабатываются асинхронно

### 4. Telegram Bot (Отдельный контейнер)

**Что делает:**
- Принимает команды от пользователей в Telegram
- Получает задачи уведомлений из Redis
- Отправляет уведомления пользователям

**Команды:**
- `/start` - регистрация/приветствие, сохранение chat_id
- `/settings` - настройки уведомлений
- `/notifications` - управление уведомлениями

**Как работает:**
1. Пользователь отправляет `/start` боту
2. Бот сохраняет chat_id в БД
3. Backend отправляет уведомления в Redis Queue
4. Telegram бот получает задачи и отправляет сообщения

**Архитектура:**
```
Telegram User → Telegram API → Telegram Bot Container
                                      ↓
                                 Redis Queue
                                      ↓
                              Notification Tasks
```

### 5. Trading Bots (Торговые боты - заглушки)

**Планируемая архитектура:**

Каждый тип бота работает в отдельном контейнере:
- Grid Bot - сеточная торговля
- DCA Bot - усреднение позиции
- Custom Bot - кастомные стратегии

**Как будет работать:**
1. Backend отправляет команду боту через Redis
2. Бот загружает конфигурацию из БД
3. Бот расшифровывает API ключи
4. Бот выполняет торговую стратегию
5. Бот обновляет статус в БД
6. Бот отправляет уведомления о событиях

## Потоки данных

### Поток 1: Создание и запуск бота

```
1. Пользователь → POST /api/bots
   {
     "name": "My Bot",
     "exchange": "binance",
     "strategy": "grid",
     "api_key": "...",
     "api_secret": "..."
   }

2. Backend:
   - Валидирует данные
   - Шифрует API ключи
   - Сохраняет в БД
   - Отправляет команду в Redis Queue

3. Trading Bot:
   - Получает команду из Redis
   - Загружает конфигурацию из БД
   - Инициализирует стратегию
   - Начинает работу

4. Backend → Уведомление:
   - Отправляет в notification_queue
   - Telegram бот отправляет сообщение пользователю
```

### Поток 2: Выставление ордера

```
1. Пользователь → POST /api/orders
   {
     "bot_id": 1,
     "symbol": "BTC/USDT",
     "side": "buy",
     "type": "limit",
     "quantity": 0.001,
     "price": 50000
   }

2. Backend:
   - Проверяет права доступа
   - Получает бота из БД
   - Расшифровывает API ключи
   - Вызывает ccxt для создания ордера на бирже

3. Биржа:
   - Создает ордер
   - Возвращает order_id

4. Backend:
   - Сохраняет ордер в БД
   - Добавляет в order_monitoring_queue
   - Отправляет уведомление

5. Order Monitor Worker:
   - Периодически проверяет статус ордера
   - Обновляет статус в БД
   - Отправляет уведомления при изменении
```

### Поток 3: Система уведомлений

```
1. Событие в системе (например, ордер исполнен)

2. NotificationService:
   - Получает настройки пользователя из БД
   - Проверяет, включены ли уведомления для этого типа события
   - Формирует задачу уведомления
   - Добавляет в notification_queue

3. Telegram Bot Worker:
   - Получает задачу из Redis
   - Форматирует сообщение
   - Отправляет через Telegram Bot API

4. Email Worker (если включен):
   - Получает задачу из Redis
   - Форматирует HTML письмо
   - Отправляет через SMTP
```

## Безопасность

### Шифрование API ключей

**Проблема:** API ключи бирж - это критически важные данные, которые нельзя хранить в открытом виде.

**Решение:**
- Используется Fernet (симметричное шифрование)
- Ключ шифрования генерируется из SECRET_KEY
- Ключи хранятся в БД в зашифрованном виде
- Расшифровка происходит только при использовании

**Процесс:**
```python
# При создании бота
api_key_encrypted = encrypt(api_key)  # Сохраняется в БД

# При использовании
api_key = decrypt(api_key_encrypted)  # Расшифровывается в памяти
```

### JWT токены

- Токены содержат user_id
- Имеют срок действия (по умолчанию 30 минут)
- Подписываются секретным ключом
- Проверяются на каждом защищенном запросе

### Валидация данных

- Все входные данные валидируются через Pydantic
- Проверка прав доступа (пользователь может управлять только своими ботами)
- Защита от SQL инъекций (SQLAlchemy ORM)

## Типы событий для уведомлений

Система отправляет уведомления при следующих событиях:

1. **bot_created** - создан новый бот
2. **bot_stopped** - бот остановлен
3. **order_placed** - выставлен ордер
4. **order_filled** - ордер исполнен
5. **order_cancelled** - ордер отменен
6. **exchange_error** - ошибка при работе с биржей
7. **bot_error** - критическая ошибка бота
8. **target_reached** - достигнут целевой уровень

Пользователь может настроить, какие события ему интересны.

## Интеграция с биржами

### Библиотека ccxt

Используется универсальная библиотека `ccxt` для работы с биржами:

**Преимущества:**
- Единый интерфейс для разных бирж
- Поддержка Binance, Bybit и многих других
- Автоматическая обработка различий между биржами

**Использование:**
```python
# Создание клиента
exchange = ccxt.binance({
    'apiKey': api_key,
    'secret': api_secret
})

# Создание ордера
order = exchange.create_order('BTC/USDT', 'limit', 'buy', 0.001, 50000)

# Проверка статуса
status = exchange.fetch_order(order_id, 'BTC/USDT')
```

## Мониторинг ордеров

### Как работает отслеживание

1. **Добавление в очередь:**
   - При создании ордера задача добавляется в `order_monitoring_queue`
   - Формат: `{"order_id": 123, "action": "monitor"}`

2. **Воркер мониторинга:**
   - Получает задачи из Redis
   - Запрашивает статус ордера на бирже
   - Сравнивает с текущим статусом в БД
   - Обновляет БД при изменении
   - Отправляет уведомления

3. **Автоматические действия:**
   - При исполнении ордера - уведомление пользователю
   - При отмене - логирование и уведомление
   - При ошибке - критическое уведомление

## Масштабируемость

### Горизонтальное масштабирование

**Backend API:**
- Можно запустить несколько экземпляров
- Используют общую БД и Redis
- Нагрузка распределяется через балансировщик

**Trading Bots:**
- Каждый тип бота в отдельном контейнере
- Можно запустить несколько экземпляров одного типа
- Распределение нагрузки через Redis Queue

**Telegram Bot:**
- Можно запустить несколько экземпляров
- Telegram API автоматически распределяет сообщения

### Вертикальное масштабирование

- Увеличение ресурсов контейнеров
- Оптимизация запросов к БД
- Кеширование в Redis

## Отказоустойчивость

### Изоляция компонентов

- Падение одного бота не влияет на другие
- Падение Telegram бота не останавливает торговлю
- Падение Backend не влияет на работающие боты (если они уже запущены)

### Восстановление

- Контейнеры автоматически перезапускаются (`restart: unless-stopped`)
- Redis сохраняет задачи в памяти
- PostgreSQL сохраняет все данные на диск

### Мониторинг

- Health check endpoints
- Логирование всех операций
- Структурированные логи для анализа

## Разработка и тестирование

### Локальная разработка

1. **Hot-reload:**
   - Файлы монтируются как volumes
   - Изменения применяются автоматически
   - Не нужно пересобирать контейнеры

2. **Логи:**
   - Все логи доступны через `docker-compose logs`
   - Структурированный формат (JSON)
   - Уровни логирования настраиваются

3. **База данных:**
   - Данные сохраняются в volumes
   - Можно очистить: `docker-compose down -v`
   - Миграции через Alembic

### Тестирование API

- Swagger UI для интерактивного тестирования
- Автоматическая документация
- Примеры запросов и ответов

## Производительность

### Оптимизации

1. **Асинхронная обработка:**
   - Уведомления отправляются через очереди
   - Не блокируют основной поток

2. **Кеширование:**
   - Redis для частых запросов
   - Кеш настроек пользователей

3. **Connection pooling:**
   - SQLAlchemy использует пул соединений
   - Эффективное использование ресурсов БД

### Ограничения

- Rate limiting на уровне бирж (через ccxt)
- Ограничения Telegram API (30 сообщений в секунду)
- Ограничения SMTP серверов

## Будущие улучшения

1. **WebSocket** - real-time обновления для фронтенда
2. **Дополнительные биржи** - расширение поддержки
3. **Сложные стратегии** - машинное обучение, индикаторы
4. **Backtesting** - тестирование стратегий на исторических данных
5. **Dashboard** - веб-интерфейс для мониторинга

## Заключение

Система спроектирована для:
- **Масштабируемости** - легко добавлять новые боты и сервисы
- **Надежности** - изоляция компонентов, автоматическое восстановление
- **Безопасности** - шифрование, валидация, JWT
- **Удобства** - REST API, Swagger, уведомления

Все компоненты работают независимо, но координируются через общую БД и Redis, что обеспечивает гибкость и надежность системы.
